#!/usr/bin/env python3
"""
Maniforge - Kubernetes App Platform
A Terraform-like tool for managing Kubernetes applications
"""

import os
import sys
import yaml
import argparse
from pathlib import Path
from typing import Dict, Any, List
from collections import defaultdict
import subprocess
import tempfile
import hashlib


class ManifestDiffer:
    """Compare and show differences between manifests"""
    
    def __init__(self):
        self.current_state = {}
        self.desired_state = {}
    
    def load_current_state(self, output_dir: Path):
        """Load currently generated manifests"""
        if not output_dir.exists():
            return
        
        for app_dir in output_dir.iterdir():
            if app_dir.is_dir():
                app_name = app_dir.name
                manifest_file = app_dir / 'helm-release.yaml'
                if manifest_file.exists():
                    with open(manifest_file) as f:
                        self.current_state[app_name] = yaml.safe_load(f)
    
    def load_desired_state(self, generator, output_dir: Path):
        """Generate desired state in memory"""
        apps = generator.apps_config.get('apps', {})
        cluster_config = generator.apps_config.get('cluster', {})
        
        for app_name, app_config in apps.items():
            values = generator.translator.translate_app(app_name, app_config, cluster_config)
            
            helm_chart_config = generator.platform_config.get('helmChart', {})
            helm_release = {
                'apiVersion': 'helm.toolkit.fluxcd.io/v2beta2',
                'kind': 'HelmRelease',
                'metadata': {
                    'name': app_name,
                    'namespace': app_config.get('namespace', 'default')
                },
                'spec': {
                    'interval': '1m',
                    'chart': {
                        'spec': {
                            'chart': helm_chart_config.get('name', 'app-template'),
                            'version': helm_chart_config.get('version', '4.4.0'),
                            'sourceRef': {
                                'kind': 'HelmRepository',
                                'name': helm_chart_config.get('repository', {}).get('name', 'bjw-s'),
                                'namespace': helm_chart_config.get('repository', {}).get('namespace', 'flux-system')
                            }
                        }
                    },
                    'values': values
                }
            }
            self.desired_state[app_name] = helm_release
    
    def get_changes(self):
        """Get list of changes"""
        changes = []
        
        # New apps
        for app_name in self.desired_state:
            if app_name not in self.current_state:
                changes.append(('create', app_name, None, self.desired_state[app_name]))
        
        # Removed apps
        for app_name in self.current_state:
            if app_name not in self.desired_state:
                changes.append(('delete', app_name, self.current_state[app_name], None))
        
        # Modified apps
        for app_name in self.desired_state:
            if app_name in self.current_state:
                current = self._normalize_manifest(self.current_state[app_name])
                desired = self._normalize_manifest(self.desired_state[app_name])
                
                if current != desired:
                    changes.append(('update', app_name, self.current_state[app_name], self.desired_state[app_name]))
        
        return changes
    
    def _normalize_manifest(self, manifest):
        """Remove fields that change between runs"""
        normalized = manifest.copy()
        # Remove any fields that might change due to generation timestamps etc.
        return normalized
    
    def print_changes(self, changes):
        """Print changes in Terraform-like format"""
        if not changes:
            print("🟢 No changes. Infrastructure is up-to-date.")
            return
        
        print(f"\n📋 Plan: {len(changes)} changes\n")
        
        for action, app_name, current, desired in changes:
            if action == 'create':
                print(f"  🟢 {app_name}")
                print(f"      App will be created")
                print(f"      Image: {self._get_image_from_values(desired.get('spec', {}).get('values', {}))}")
                print(f"      Namespace: {desired.get('metadata', {}).get('namespace', 'default')}")
                
            elif action == 'delete':
                print(f"  🔴 {app_name}")
                print(f"      App will be deleted")
                
            elif action == 'update':
                print(f"  🟡 {app_name}")
                print(f"      App will be modified")
                
                # Show specific changes
                current_image = self._get_image_from_values(current.get('spec', {}).get('values', {}))
                desired_image = self._get_image_from_values(desired.get('spec', {}).get('values', {}))
                
                if current_image != desired_image:
                    print(f"      Image: {current_image} → {desired_image}")
                
                # Check for resource changes
                current_resources = self._get_resources_from_values(current.get('spec', {}).get('values', {}))
                desired_resources = self._get_resources_from_values(desired.get('spec', {}).get('values', {}))
                
                if current_resources != desired_resources:
                    print(f"      Resources will be updated")
            
            print()
    
    def _get_image_from_values(self, values):
        """Extract image from helm values"""
        try:
            container = values.get('controllers', {}).get('main', {}).get('containers', {}).get('main', {})
            image_config = container.get('image', {})
            repo = image_config.get('repository', '')
            tag = image_config.get('tag', 'latest')
            return f"{repo}:{tag}" if repo else "unknown"
        except:
            return "unknown"
    
    def _get_resources_from_values(self, values):
        """Extract resources from helm values"""
        try:
            container = values.get('controllers', {}).get('main', {}).get('containers', {}).get('main', {})
            return container.get('resources', {})
        except:
            return {}


class AppTranslator:
    """Translates high-level app config to bjw-s-app-template values"""
    
    def __init__(self, platform_config: Dict[str, Any]):
        self.platform = platform_config
        self.resource_profiles = platform_config.get('resourceProfiles', {})
        self.network_types = platform_config.get('networkTypes', {})
        self.storage_types = platform_config.get('storageTypes', {})
        self.ingress_defaults = platform_config.get('ingressDefaults', {})
        self.node_selectors = platform_config.get('nodeSelectors', {})
    
    def translate_image(self, image_str: str) -> Dict[str, Any]:
        """Convert image string to repository:tag format"""
        if ':' in image_str:
            repo, tag = image_str.rsplit(':', 1)
        else:
            repo, tag = image_str, 'latest'
        
        return {
            'repository': repo,
            'tag': tag
        }
    
    def translate_network(self, network_type: str, ports: List[Dict] = None) -> Dict[str, Any]:
        """Convert network type to service and pod configuration"""
        network_config = self.network_types.get(network_type, {})
        
        result = {
            'service': {
                'main': {
                    'controller': 'main',
                    'type': network_config.get('service', {}).get('type', 'ClusterIP'),
                    'ports': {}
                }
            }
        }
        
        # Add pod options if specified
        pod_options = network_config.get('podOptions', {})
        if pod_options:
            result['defaultPodOptions'] = pod_options
        
        # Configure ports
        if ports:
            for i, port_config in enumerate(ports):
                port_name = port_config.get('name', f'port-{i}')
                result['service']['main']['ports'][port_name] = {
                    'enabled': True,
                    'port': port_config['port'],
                    'targetPort': port_config.get('targetPort', port_config['port']),
                    'protocol': port_config.get('protocol', 'TCP')
                }
                
                if network_config.get('service', {}).get('type') == 'NodePort' and 'nodePort' in port_config:
                    result['service']['main']['ports'][port_name]['nodePort'] = port_config['nodePort']
        else:
            result['service']['main']['ports']['http'] = {
                'enabled': True,
                'port': 80,
                'targetPort': 8080,
                'protocol': 'TCP'
            }
        
        return result
    
    def translate_storage(self, storage_config: Dict[str, Any]) -> Dict[str, Any]:
        """Convert storage configuration to persistence"""
        persistence = {}
        
        for volume_name, volume_config in storage_config.items():
            volume_type = volume_config['type']
            
            persistence_volume = {
                'enabled': True,
                'type': volume_type,
                'globalMounts': [{
                    'path': volume_config['mount'],
                    'readOnly': volume_config.get('readonly', False)
                }]
            }
            
            if volume_type == 'hostPath':
                persistence_volume['hostPath'] = volume_config['path']
            elif volume_type == 'persistentVolumeClaim':
                persistence_volume['size'] = volume_config['size']
                if 'storageClass' in volume_config:
                    persistence_volume['storageClass'] = volume_config['storageClass']
                persistence_volume['accessMode'] = volume_config.get('accessMode', 'ReadWriteOnce')
            elif volume_type == 'nfs':
                persistence_volume['server'] = volume_config['server']
                persistence_volume['path'] = volume_config['path']
            
            persistence[volume_name] = persistence_volume
        
        return {'persistence': persistence} if persistence else {}
    
    def translate_resources(self, profile_name: str) -> Dict[str, Any]:
        """Convert resource profile to resources configuration"""
        profile = self.resource_profiles.get(profile_name, {})
        if not profile:
            return {}
        
        return {
            'controllers': {
                'main': {
                    'containers': {
                        'main': {
                            'resources': {
                                'requests': {
                                    'cpu': profile.get('cpu', {}).get('requests', '100m'),
                                    'memory': profile.get('memory', {}).get('requests', '128Mi')
                                },
                                'limits': {
                                    'cpu': profile.get('cpu', {}).get('limits', '500m'),
                                    'memory': profile.get('memory', {}).get('limits', '512Mi')
                                }
                            }
                        }
                    }
                }
            }
        }
    
    def translate_node_selector(self, node_selector: str) -> Dict[str, Any]:
        """Convert node selector to pod options"""
        node_config = self.node_selectors.get(node_selector, {})
        labels = node_config.get('labels', {})
        
        if labels:
            return {
                'defaultPodOptions': {
                    'nodeSelector': labels
                }
            }
        return {}
    
    def translate_ingress(self, app_name: str, domain: str, enabled: bool = True) -> Dict[str, Any]:
        """Generate ingress configuration"""
        if not enabled:
            return {}
        
        return {
            'ingress': {
                'main': {
                    'enabled': True,
                    'className': self.ingress_defaults.get('className', 'traefik'),
                    'annotations': self.ingress_defaults.get('annotations', {}),
                    'hosts': [
                        {
                            'host': f"{app_name}.{domain}",
                            'paths': [
                                {
                                    'path': '/',
                                    'pathType': 'Prefix',
                                    'service': {
                                        'identifier': 'main',
                                        'port': 'http'
                                    }
                                }
                            ]
                        }
                    ],
                    'tls': [
                        {
                            'hosts': [f"{app_name}.{domain}"],
                            'secretName': f"{app_name}-tls"
                        }
                    ]
                }
            }
        }
    
    def translate_app(self, app_name: str, app_config: Dict[str, Any], cluster_config: Dict[str, Any]) -> Dict[str, Any]:
        """Translate a complete app configuration"""
        values = {
            'controllers': {
                'main': {
                    'type': app_config.get('type', 'deployment'),
                    'containers': {
                        'main': {
                            'image': self.translate_image(app_config['image']),
                            'env': app_config.get('env', {})
                        }
                    }
                }
            },
            'defaultPodOptions': {}
        }
        
        # Apply configurations with deep merge
        configurations = [
            ('profile', lambda: self.translate_resources(app_config.get('profile', cluster_config.get('defaults', {}).get('profile')))),
            ('nodeSelector', lambda: self.translate_node_selector(app_config.get('nodeSelector', cluster_config.get('defaults', {}).get('nodeSelector')))),
            ('network', lambda: self.translate_network(app_config.get('network', 'clusterip'), app_config.get('ports', []))),
            ('storage', lambda: self.translate_storage(app_config['storage']) if 'storage' in app_config else {}),
            ('ingress', lambda: self.translate_ingress(app_name, cluster_config.get('domain')) if cluster_config.get('domain') and app_config.get('ingress', True) else {})
        ]
        
        for name, func in configurations:
            config = func()
            if config:
                self._deep_merge(values, config)
        
        return values
    
    def _deep_merge(self, target: Dict, source: Dict):
        """Deep merge source dict into target dict"""
        for key, value in source.items():
            if key in target and isinstance(target[key], dict) and isinstance(value, dict):
                self._deep_merge(target[key], value)
            else:
                target[key] = value


class Maniforge:
    """Main Maniforge application"""
    
    def __init__(self, config_file: str = 'maniforge.yaml'):
        self.config_file = Path(config_file)
        self.load_config()
        self.translator = AppTranslator(self.platform_config)
    
    def load_config(self):
        """Load maniforge configuration"""
        if not self.config_file.exists():
            print(f"❌ Configuration file not found: {self.config_file}")
            print("Run 'maniforge init' to create a new configuration")
            sys.exit(1)
        
        with open(self.config_file) as f:
            self.config = yaml.safe_load(f)
        
        # Load platform config (could be remote in the future)
        platform_file = Path(self.config.get('platform', {}).get('file', 'platform.yaml'))
        if platform_file.exists():
            with open(platform_file) as f:
                self.platform_config = yaml.safe_load(f)
        else:
            self.platform_config = self._default_platform_config()
        
        self.apps_config = self.config
    
    def _default_platform_config(self):
        """Default platform configuration"""
        return {
            'resourceProfiles': {
                'c.pico': {'cpu': {'requests': '100m', 'limits': '250m'}, 'memory': {'requests': '256Mi', 'limits': '512Mi'}},
                'c.small': {'cpu': {'requests': '250m', 'limits': '500m'}, 'memory': {'requests': '512Mi', 'limits': '1Gi'}},
                'r.large': {'cpu': {'requests': '500m', 'limits': '1000m'}, 'memory': {'requests': '4Gi', 'limits': '8Gi'}}
            },
            'networkTypes': {
                'clusterip': {'service': {'type': 'ClusterIP'}, 'podOptions': {}},
                'nodeport': {'service': {'type': 'NodePort'}, 'podOptions': {}},
                'host': {'service': {'type': 'ClusterIP'}, 'podOptions': {'hostNetwork': True, 'dnsPolicy': 'ClusterFirstWithHostNet'}}
            },
            'nodeSelectors': {
                'pi': {'labels': {'type': 'pi'}, 'capacity': {'cpu': '4000m', 'memory': '8Gi'}}
            },
            'ingressDefaults': {
                'className': 'traefik',
                'annotations': {
                    'traefik.ingress.kubernetes.io/router.entrypoints': 'websecure',
                    'traefik.ingress.kubernetes.io/router.tls': 'true',
                    'cert-manager.io/cluster-issuer': 'letsencrypt-dns'
                }
            },
            'helmChart': {'name': 'app-template', 'version': '4.4.0', 'repository': {'name': 'bjw-s', 'namespace': 'flux-system'}}
        }
    
    def validate(self):
        """Validate configuration"""
        errors = []
        apps = self.apps_config.get('apps', {})
        cluster_config = self.apps_config.get('cluster', {})
        
        for app_name, app_config in apps.items():
            if 'image' not in app_config:
                errors.append(f"App '{app_name}': missing required field 'image'")
            
            profile = app_config.get('profile', cluster_config.get('defaults', {}).get('profile'))
            if profile and profile not in self.platform_config.get('resourceProfiles', {}):
                errors.append(f"App '{app_name}': unknown profile '{profile}'")
            
            network = app_config.get('network', 'clusterip')
            if network not in self.platform_config.get('networkTypes', {}):
                errors.append(f"App '{app_name}': unknown network type '{network}'")
        
        if errors:
            print("❌ VALIDATION ERRORS:")
            for error in errors:
                print(f"  - {error}")
            return False
        
        return True
    
    def plan(self):
        """Show what changes would be made (like terraform plan)"""
        print("🔍 Validating configuration...")
        if not self.validate():
            sys.exit(1)
        
        print("✅ Configuration is valid")
        print("\n📋 Generating plan...")
        
        output_dir = Path(self.config.get('output', {}).get('directory', 'apps'))
        
        differ = ManifestDiffer()
        differ.load_current_state(output_dir)
        differ.load_desired_state(self, output_dir)
        
        changes = differ.get_changes()
        differ.print_changes(changes)
        
        return len(changes) > 0
    
    def apply(self):
        """Apply changes (like terraform apply)"""
        print("🔍 Validating configuration...")
        if not self.validate():
            sys.exit(1)
        
        print("✅ Configuration is valid")
        print("\n🔧 Applying changes...")
        
        output_dir = Path(self.config.get('output', {}).get('directory', 'apps'))
        self.generate(output_dir)
        
        print("\n✅ Apply complete!")
    
    def generate(self, output_dir: Path):
        """Generate manifests"""
        apps = self.apps_config.get('apps', {})
        cluster_config = self.apps_config.get('cluster', {})
        
        for app_name, app_config in apps.items():
            values = self.translator.translate_app(app_name, app_config, cluster_config)
            
            kustomization = {
                'apiVersion': 'kustomize.config.k8s.io/v1beta1',
                'kind': 'Kustomization',
                'namespace': app_config.get('namespace', 'default'),
                'resources': ['helm-release.yaml']
            }
            
            helm_chart_config = self.platform_config.get('helmChart', {})
            helm_release = {
                'apiVersion': 'helm.toolkit.fluxcd.io/v2beta2',
                'kind': 'HelmRelease',
                'metadata': {
                    'name': app_name,
                    'namespace': app_config.get('namespace', 'default')
                },
                'spec': {
                    'interval': '1m',
                    'chart': {
                        'spec': {
                            'chart': helm_chart_config.get('name', 'app-template'),
                            'version': helm_chart_config.get('version', '4.4.0'),
                            'sourceRef': {
                                'kind': 'HelmRepository',
                                'name': helm_chart_config.get('repository', {}).get('name', 'bjw-s'),
                                'namespace': helm_chart_config.get('repository', {}).get('namespace', 'flux-system')
                            }
                        }
                    },
                    'values': values
                }
            }
            
            app_dir = output_dir / app_name
            app_dir.mkdir(parents=True, exist_ok=True)
            
            with open(app_dir / 'kustomization.yaml', 'w') as f:
                yaml.dump(kustomization, f, default_flow_style=False, sort_keys=False)
            
            with open(app_dir / 'helm-release.yaml', 'w') as f:
                yaml.dump(helm_release, f, default_flow_style=False, sort_keys=False)
            
            print(f"  ✅ {app_name}")
    
    def init(self, cluster_name: str = 'firefly'):
        """Initialize a new maniforge project"""
        if self.config_file.exists():
            print(f"❌ Configuration already exists: {self.config_file}")
            sys.exit(1)
        
        config = {
            'platform': {
                'source': 'built-in',
                'version': 'v1.0.0'
            },
            'cluster': {
                'name': cluster_name,
                'domain': 'example.com',
                'defaults': {
                    'profile': 'c.small',
                    'nodeSelector': 'pi'
                }
            },
            'output': {
                'directory': 'apps'
            },
            'apps': {
                'nginx-example': {
                    'image': 'nginx:latest',
                    'type': 'deployment',
                    'network': 'clusterip',
                    'profile': 'c.small'
                }
            }
        }
        
        with open(self.config_file, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)
        
        print(f"✅ Initialized maniforge project: {self.config_file}")
        print("Edit the configuration and run 'maniforge plan' to see what will be created")


def main():
    parser = argparse.ArgumentParser(description='Maniforge - Kubernetes App Platform')
    parser.add_argument('--config', '-c', default='maniforge.yaml', help='Configuration file')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # init command
    init_parser = subparsers.add_parser('init', help='Initialize a new project')
    init_parser.add_argument('--cluster', default='firefly', help='Cluster name')
    
    # plan command
    subparsers.add_parser('plan', help='Show what changes would be made')
    
    # apply command
    subparsers.add_parser('apply', help='Apply changes')
    
    # validate command
    subparsers.add_parser('validate', help='Validate configuration')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    if args.command == 'init':
        maniforge = Maniforge(args.config)
        maniforge.init(args.cluster)
        return
    
    maniforge = Maniforge(args.config)
    
    if args.command == 'plan':
        has_changes = maniforge.plan()
        sys.exit(1 if has_changes else 0)  # Terraform-like exit codes
    
    elif args.command == 'apply':
        maniforge.apply()
    
    elif args.command == 'validate':
        if maniforge.validate():
            print("✅ Configuration is valid")
        else:
            sys.exit(1)


if __name__ == '__main__':
    main()